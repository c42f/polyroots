from __future__ import division
from pylab import *

#-------------------------------------------------------------------------------
# Some utility stuff

# Iterator returning all elements in the caretesian power S^n of the set S
def setCartesianPower(S, n):
    if n == 1:
        for i in S:
            yield (i,)
    else:
        for j in setCartesianPower(S, n-1):
            for i in S:
                yield (i,) + j

# Compute all Nth roots of unity
def rootsOfUnity(N):
    t = 2*pi*arange(N)/N
    return cos(t) + 1j*sin(t)

#-------------------------------------------------------------------------------
# Code to generate and display images of minimum of abs of all polys of given
# degree with all permutations of a coeffSet.

# Make domain contained in (0,R)x(0,R) of size npoints x npoints.
# Note, x==0 & y==0 lines excluded on purpose so assembleSym can be used to
# assemble the result.
def makeDomain(R, npoints):
    #x1 = linspace(-R,R,npoints)  # not making use of symmetry
    x1 = R/npoints*(arange(npoints) + 0.5)
    x,y = meshgrid(x1, x1)
    return x + 1j*y

def makePolarDomain(R, npoints):
    # First quadrant of complex plane in polar coords.
    theta = pi/2 * (arange(npoints) + 0.5)/npoints
    npointsRad = (R - 1) * npoints / (pi/2)
    r = 1 + (R - 1)*(arange(npointsRad) + 0.5)/npointsRad
    tt,rr = meshgrid(theta,r)
    x,y = rr*cos(tt), rr*sin(tt)
    return x + 1j*y

# Render roots with Sjoerd Visscher's direct evaluation algorithm.
#
# degree   - polynomial degree
# z        - coordinates in complex plane
# coeffSet - set of coefficients for each z^n term.
def minPolyFractal(degree, z, coeffSet=(-1,1)):
    N = degree + 1
    zPows = [z**i for i in range(0,N)]
    acc = 1000*ones(z.shape)
    for coeffs in setCartesianPower(coeffSet, N):
        p = 0
        # TODO: Use recursive eval rather than redoing sum for each poly.
        for zpow,c in zip(zPows,coeffs):
            p += c*zpow
        acc = fmin(acc, absolute(p))
    return acc*abs(z)**(-degree/2)

# Assemble a symmetrical 'root fractal' from the first quadrant by mirroring
# and concatenation.  Use with coeffSet=(-1,1)
def assembleSym(F):
    F1 = concatenate((fliplr(F), F), axis=1)
    return concatenate((flipud(F1), F1), axis=0)

# Read binary data file generated by C++ code.
def readDataFile(name):
    f = open(name, 'rb')
    N, M = (int(i) for i in f.readline().split())
    return fromfile(f, dtype=float32, count=N*M).reshape(M,N)

# Show min abs polynomial fractal with reprsentative heat map + scaling.
def imsh(F, **a):
    imshow(F**0.01, cmap=cm.gist_heat_r, origin='lower',
           vmin=0.95,vmax=1.1, **a)


#-------------------------------------------------------------------------------
# Exact computation of roots

# polyCoeffs is a list of tuples, each tuple representing coefficents of a
# single polynomial.  collectRoots() collects all complex roots from these,
# and returns them in a huge array.
def collectRoots(polyCoeffs):
    r = []
    for coeffs in polyCoeffs:
        r.extend(roots(coeffs))
    return array(r)


# Compute all roots of all polynomials with coefficients in coeffSet
def allRoots(coeffSet, degree):
    return collectRoots(setCartesianPower(coeffSet, degree+1))


# Polynomial coefficients for all polys with +/-1 coeffs which may have roots
# in the given bounding box in the complex plane.
#
# bound - list of four numbers [left, right, bottom, top] describing region of
#         the complex plane in which to look for polynomials with roots
# degree - polynomial degree
# coeffSet - set of polynomial coefficients
#
# returns a list of tuples containing the polynomial coefficients.  The
# ordering of coefficients is from highest power to lowest (this convention is
# the same as the pylab polynomial functions polyval, polyder etc.
def polysInBound(bound, degree, coeffSet=(-1,1)):
    import mpmath
    mpc = mpmath.iv.mpc
    mpi = mpmath.mpi
    # Get interval in complex plane; remap to inside unit circle if necessary
    # so that higher z powers decay.
    zbnd = mpc(mpi(bound[0], bound[1]), mpi(bound[2], bound[3]))
    z0 = mean(bound[:2]) + 1j*mean(bound[2:])
    remapped = False
    if abs(zbnd).b > 1:
        if abs(zbnd).a < 1:
            raise RuntimeError('bound touches unit circle')
        z0 = 1/z0
        # mpmath's complex inverse operation doesn't return a tight bound.
        # To get an approximate tight bound, let's just do a braindead
        # sampling of the region on a regular grid, and wrap 1/region in an
        # interval:
        zx,zy = meshgrid(linspace(bound[0], bound[1]),
                         linspace(bound[2], bound[3]))
        zinvSamp = (1/(zx + 1j*zy)).flatten()
        zbnd = mpc(mpi(min(real(zinvSamp)), max(real(zinvSamp))),
                   mpi(min(imag(zinvSamp)), max(imag(zinvSamp))))
        remapped = True
    # Normalize the coefficient set so that max coeff magnitude is 1.  This
    # doesn't change the roots and makes things simpler.
    coeffSet = array(coeffSet)
    coeffSet = coeffSet/max(abs(coeffSet))
    # Precompute powers of z.  It is critical to use the power function for
    # intervals rather than successive multiplication to avoid very
    # pessimistic bounds.  (z**2 != z*z in interval arithmetic!)
    n = arange(degree+1)
    z0pows = z0**n
    dzpowsdz = n*zbnd**(n-1)
    dzpowsdz[0] = 0
    # Bound on absolute value of sum of last n terms:
    absBounds = cumsum(abs(zbnd**n)[::-1])[::-1]
    # Recursive function traversing the tree of all polynomials, pruning away
    # parts of the tree which cannot have zeros inside the given bound.
    #
    # We compute a bound for P in the complex plane by computing P(z0), and
    # dPdz(zbnd) where zbnd is the complex interval of interest and z0 is the
    # centre.  Using Taylor's theorem we can then estimate the complex
    # interval P(zbnd) much more accurately than computing P(zbnd) directly,
    # provided the function is approximately linear.
    def evalPoly(resultList, partialCoeffs, P0, dPdz, n):
        if n == 0:
            coeffs = partialCoeffs
            if not remapped:
                coeffs = partialCoeffs[::-1]
            resultList.append(coeffs)
        else:
            # Note > and <= are not mutually exclusive for intervals!
            if abs(P0 + dPdz*(zbnd-z0)) > absBounds[-n]:
                pass # trim recursive branch.
            else:
                for c in coeffSet:
                    evalPoly(resultList, partialCoeffs + (c,),
                             P0 + c*z0pows[-n], dPdz + c*dzpowsdz[-n], n-1)
    # Collect results as a list of polynomial coefficients
    resultList = []
    evalPoly(resultList, (), 0, 0, degree+1)
    return resultList


#------------------------------------------------------------------------------
#------------------------------------------------------------------------------
# Script stuff

# Some interesting looking coeff sets:

# cset = (-1,1)
# cset = (0,1)
# cset = (1,1j)
# cset = rootsOfUnity(3)

#-------------------------------------------
# Basic min of all polynomials visualisation
#cset = (-1,1)
## Low degree example because minPolyFractal sucks!  The C++ code is much
## faster.
#deg = 8
#
#R = 2.1
#x1 = linspace(-R,R,400)
#x,y = meshgrid(x1, x1)
#z = x + 1j*y
#
#F = minPolyFractal(deg, z, cset)
#clf()
#imsh(F, extent=[-R,R,-R,R])
#
#r = allRoots(cset, deg)
#plot(real(r), imag(r), '.', markersize=1)
#axis('equal')
#xlim([-R,R])
#ylim([-R,R])
#show()

#-------------------------------------------
#clf()
#r = allRoots((1,1j), 13)
#plot(real(r), imag(r), '.', markersize=1)
#axis('equal')
#show()

# Compute roots in a deep zoom
clf()
degree = 38
coeffSet = (-1,1)
bnd = [1.460076, 1.460176, 0.200166, 0.200266]

#degree = 27
#coeffSet = (1,1j)
#bnd = [-1.2078263 , -1.20423965,  0.88100003,  0.8835998 ]

bndOutlineX = array([bnd[0],bnd[1],bnd[1],bnd[0],bnd[0]])
bndOutlineY = array([bnd[2],bnd[2],bnd[3],bnd[3],bnd[2]])

bndCentre = mean(bnd[:2]) + 1j*mean(bnd[2:])
bndRad = min(sqrt((bndOutlineX - bndCentre.real)**2 +
                  (bndOutlineY - bndCentre.imag)**2))
polys = polysInBound(bnd, degree, coeffSet)
rootsToPlot = []
for c in polys:
    #r = roots(c)
    r = [r for r in roots(c) if abs(r - bndCentre) < 10*bndRad]
    rootsToPlot.append(r)
rootsToPlot = array(rootsToPlot).flatten()
plot(real(rootsToPlot), imag(rootsToPlot), 'k.', markersize=1)

#x,y = meshgrid(linspace(bnd[0], bnd[1],200), linspace(bnd[2], bnd[3],200))
#z = x + 1j*y
#minAbsP = 1e10*ones(z.shape)
#for c in polys:
#    fmin(minAbsP, abs(polyval(c, z)), minAbsP)
#imsh(minAbsP, extent=bnd)

plot(bndOutlineX, bndOutlineY, 'k-')
axis('equal')
xlim(bnd[:2])
ylim(bnd[2:])

show()
