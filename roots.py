from __future__ import division
from pylab import *

#-------------------------------------------------------------------------------
# Some utility stuff

# Iterator returning all elements in the caretesian power S^n of the set S
def setCartesianPower(S, n):
    if n == 1:
        for i in S:
            yield (i,)
    else:
        for j in setCartesianPower(S, n-1):
            for i in S:
                yield (i,) + j

# Compute all Nth roots of unity
def rootsOfUnity(N):
    t = 2*pi*arange(N)/N
    return cos(t) + 1j*sin(t)

#-------------------------------------------------------------------------------
# Code to generate and display images of minimum of abs of all polys of given
# degree with all permutations of a coeffSet.

# Make domain contained in (0,R)x(0,R) of size npoints x npoints.
# Note, x==0 & y==0 lines excluded on purpose so assembleSym can be used to
# assemble the result.
def makeDomain(R, npoints):
    #x1 = linspace(-R,R,npoints)  # not making use of symmetry
    x1 = R/npoints*(arange(npoints) + 0.5)
    x,y = meshgrid(x1, x1)
    return x + 1j*y

def makePolarDomain(R, npoints):
    # First quadrant of complex plane in polar coords.
    theta = pi/2 * (arange(npoints) + 0.5)/npoints
    npointsRad = (R - 1) * npoints / (pi/2)
    r = 1 + (R - 1)*(arange(npointsRad) + 0.5)/npointsRad
    tt,rr = meshgrid(theta,r)
    x,y = rr*cos(tt), rr*sin(tt)
    return x + 1j*y

# Render roots with Sjoerd Visscher's direct evaluation algorithm.
#
# degree   - polynomial degree
# z        - coordinates in complex plane
# coeffSet - set of coefficients for each z^n term.
def minPolyFractal(degree, z, coeffSet=(-1,1)):
    N = degree + 1
    zPows = [z**i for i in range(0,N)]
    acc = 1000*ones(z.shape)
    for coeffs in setCartesianPower(coeffSet, N):
        p = 0
        # TODO: Use recursive eval rather than redoing sum for each poly.
        for zpow,c in zip(zPows,coeffs):
            p += c*zpow
        acc = fmin(acc, absolute(p))
    return acc*abs(z)**(-degree/2)

# Assemble a symmetrical 'root fractal' from the first quadrant by mirroring
# and concatenation.  Use with coeffSet=(-1,1)
def assembleSym(F):
    F1 = concatenate((fliplr(F), F), axis=1)
    return concatenate((flipud(F1), F1), axis=0)

# Read binary data file generated by C++ code.
def readDataFile(name):
    f = open(name, 'rb')
    N, M = (int(i) for i in f.readline().split())
    return fromfile(f, dtype=float32, count=N*M).reshape(M,N)

# Show min abs polynomial fractal with reprsentative heat map + scaling.
def imsh(F, **a):
    imshow(F**0.01, cmap=cm.gist_heat_r, origin='lower',
           vmin=0.95,vmax=1.1, **a)


#-------------------------------------------------------------------------------
# Exact computation of roots

# polyCoeffs is a list of tuples, each tuple representing coefficents of a
# single polynomial.  collectRoots() collects all complex roots from these,
# and returns them in a huge array.
def collectRoots(polyCoeffs):
    r = []
    for coeffs in polyCoeffs:
        r.extend(roots(coeffs))
    return array(r)


# Compute all roots of all polynomials with coefficients in coeffSet
def allRoots(coeffSet, degree):
    return collectRoots(setCartesianPower(coeffSet, degree+1))


# Polynomial coefficients for all polys with +/-1 coeffs which also might have
# roots in the given bounding box in the complex plane.
#
# TODO: Buggy?  Finds rather too many roots?  Needs more investigation.
def polysInBound(left, bottom, right, top, degree):
    def evalPoly(resultList, partialCoeffs, partialPoly, absBounds, zpows, n):
        if n == 0:
            resultList.append(partialCoeffs)
        else:
            # Note > and <= are not mutually exclusive for intervals!
            if abs(partialPoly) > absBounds[-n]:
                pass # trim recursive branch.
            else:
                #import pdb; pdb.set_trace()
                evalPoly(resultList, partialCoeffs + (1,),
                        partialPoly + zpows[-n], absBounds, zpows, n-1)
                evalPoly(resultList, partialCoeffs + (-1,),
                        partialPoly - zpows[-n], absBounds, zpows, n-1)

    # TODO: allow general coefficient sets
    # Compute interval in complex plane; remap to inside unit circle.
    # TODO: Need to reverse coefficients if this is done.
    from mpmath import iv, mpi, mpc
    z = mpi(left, right) + 1j * mpi(bottom, top)
    if abs(z).b > 1:
        if abs(z).a < 1:
            raise RuntimeError('bound touches unit circle')
        z = 1.0/z
    # Precompute powers of z.  It is critical to use the power function here
    # rather than successive multiplication to avoid very pessimistic bounds.
    # (Actually, perhaps this isn't enough to entirely avoid pessimistic
    # bounds?)
    zpowers = z**arange(degree+1)
    # Bound on absolute value of sum of last n terms:
    absBounds = cumsum(abs(zpowers)[::-1])[::-1]
    resultList = []
    evalPoly(resultList, (), 0, absBounds, zpowers, degree+1)
    return resultList


#------------------------------------------------------------------------------
#------------------------------------------------------------------------------
# Script stuff

# Some interesting looking coeff sets:

# cset = (-1,1)
# cset = (0,1)
# cset = (1,1j)
# cset = rootsOfUnity(3)

cset = (-1,1)
# Low degree example because minPolyFractal sucks!  The C++ code is much
# faster.
deg = 8

R = 2.1
x1 = linspace(-R,R,400)
x,y = meshgrid(x1, x1)
z = x + 1j*y

F = minPolyFractal(deg, z, cset)
clf()
imsh(F, extent=[-R,R,-R,R])

r = allRoots(cset, deg)
plot(real(r), imag(r), '.', markersize=1)
axis('equal')
xlim([-R,R])
ylim([-R,R])
show()
