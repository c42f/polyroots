from __future__ import division
from pylab import *

# Iterator returning all elements in the caretesian power S^n of the set S
def setCartesianPower(S, n):
    def maketuple(*t): return t
    if n == 1:
        for i in S:
            yield (i,)
    else:
        for j in setCartesianPower(S, n-1):
            for i in S:
                yield maketuple(i, *j)

def makeDomain(R, npoints):
    # Make domain contained in (0,R)x(0,R) of size npoints x npoints.
    # Note, x==0 & y==0 lines excluded on purpose so assembleSym can be used to
    # assemble the result.
    #x1 = linspace(-R,R,npoints)  # not making use of symmetry
    x1 = R/npoints*(arange(npoints) + 0.5)
    x,y = meshgrid(x1, x1)
    return x + 1j*y

def makePolarDomain(R, npoints):
    # First quadrant of complex plane in polar coords.
    theta = pi/2 * (arange(npoints) + 0.5)/npoints
    npointsRad = (R - 1) * npoints / (pi/2)
    r = 1 + (R - 1)*(arange(npointsRad) + 0.5)/npointsRad
    tt,rr = meshgrid(theta,r)
    x,y = rr*cos(tt), rr*sin(tt)
    return x + 1j*y


class MinAccumulator:
    # Accumulator: find min of all polynomials
    def __init__(self, z):
        self.acc = 1000*ones(z.shape)
    def accumulate(self, poly):
        fmin(self.acc, absolute(poly), self.acc)
    def result(self, z, degree):
        return self.acc*abs(z)**(-degree/2)

class SjoerdAccumulator:
    # Accumulator: find sum_i 1/abs(poly_i(z))^4 of all polynomials
    def __init__(self, z):
        self.acc = zeros(z.shape)
    def accumulate(self, poly):
        add(self.acc, absolute(poly)**-4, self.acc)
    def result(self, z, degree):
        return self.acc*abs(z)**(2*degree)

def genfrac(degree, z, accumClass=MinAccumulator, coeffSet=(-1,1)):
    # Render roots with Sjoerd Visscher's direct evaluation algorithm.
    #
    # z - coordinates in complex plane
    # accumClass - accumulator over polynomials.
    N = degree + 1
    zPows = [z**i for i in range(0,N)]
    acc = accumClass(z)
    for coeffs in setCartesianPower(coeffSet, N):
        p = 0
        for zpow,c in zip(zPows,coeffs):
            p += c*zpow
        acc.accumulate(p)
    return acc.result(z, degree)


def assembleSym(F):
    # Assemble a symmetrical 'root fractal' from the first quadrant
    # by mirroring and concatenation.
    F1 = concatenate((fliplr(F), F), axis=1)
    return concatenate((flipud(F1), F1), axis=0)

def readDataFile(name):
    # Read binary data file generated by C++ code.
    f = open(name, 'rb')
    N, M = (int(i) for i in f.readline().split())
    return fromfile(f, dtype=float32, count=N*M).reshape(N,M)


#R = 1.6 #z = makeDomain(1.6,1000)
#F = genfrac(7,z)
#F = assembleSym(F)
#
#xmax = amax(real(z))
#extent = (-xmax, xmax, -xmax, xmax)
#
##imshow(exp(-20*acc**2), cmap=cm.gray)
##imshow(exp(-100*abs(4-abs(z)**2)*F**2), cmap=cm.gray, origin='lower')
##imshow(F, cmap=cm.gray, origin='lower')
##imshow(F**0.1, cmap=cm.gist_heat_r, origin='lower', vmin=0.5)
#imshow(F**0.1, cmap=cm.gist_heat_r, origin='lower', vmin=0.5,
#       extent=extent, interpolation='nearest')
#imshow(F**0.01, cmap=cm.gist_heat_r, origin='lower', vmin=0.95,vmax=1.1)
#show()
imsh = lambda F, **a: imshow(F**0.01, cmap=cm.gist_heat_r, origin='lower', vmin=0.95,vmax=1.1, **a)
